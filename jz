精准测试核心思想是用例和代码的双向追溯，根据代码变更推荐对应的测试用例。在测试设计、测试执行、测试管理中有12项应用，例如用例智能选取、代码覆盖率分析、缺陷定位、聚类分析、测试进度可视化等。
一、问题的提出
传统的测试测试范围广，版本发布频繁，不知道变更的地方在哪里，不知道影响的范围有多大，通常情况要么测试范围定小了，遗漏了，要么测试范围过大，付出过多的代价。
测试人员需要明确测试对象，找到版本与版本之间的差异部分，以及差异部分所影响的功能。
二、解决思路
精准测试核心思想是建立测试用例和开发代码的双向回溯关系，即运行一个测试用例以后，可以通过程序自动的记录这个测试用例执行的代码。代码改动后，只推荐改动关联的相应测试用例，做到改哪里测哪里，并使用这些量化数据进行质量评价，促进测试过程的不断完善，目前已经挖掘了12个应用场景。


2.1  精准测试的核心思想
2.1.1  建立用例和代码的关联
执行TE用例的同时，开启一个记录程序，该记录程序可以记录Android程序运行过程中的调用路径和调用关系，建立测试用例与程序代码的关联关系。



测试用例->代码函数的对应表格

代码函数->测试用例的对应表格

    
三、精准测试的应用
3.1  精准测试设计
3.1.1  用例增加和删减
通过代码覆盖率表格指导测试补充和删除用例。
根据各模块代码覆盖率情况，找到未覆盖用例的函数或者函数分支路径并补充测试用例。可以直接和研发沟通帮助设计用例场景进行覆盖。
1.函数复杂度很高但覆盖率却很低的时候其风险概率就比较高，应该优先补充用例。
2.通过比较最近半年APK的代码变更情况，找出哪些些函数是发生过变更的，从而优先补充。有些代码是冗余代码，例如try-catch、日志、空指针的判断、预埋逻辑、尚未使用的公共代码库等则无需补充用例。
3.先完成函数覆盖的用例补充，后完成分支覆盖用例补充。
4.根据最小用例集和用例聚类来去除重复用例
5.当自动化用例和代码变更关联后，精准测试可以识别到layout的变更， 由于布局文件改变会导致UI界面的改变从而影响自动化用例，这时就可以预先进行自动化用例维护。甚至可以预先识别出改变的内容而自动修复自动化用例。一些layout变更频繁的代码，可以考虑从UI自动化用例转为不依赖UI的接口自动化用例。

3.1.2  改进用例设计方案
当某个场景的代码覆盖率不高的时候，我们可以反向追溯导致覆盖率不高的用例设计方案存在什么缺陷，从而提高用例设计水平。
3.1.3  最小用例集
由于用例存在大量冗余，可以根据代码覆盖情况优化一个满足当前代码覆盖的一个最小用例集合，这个集合里面过滤掉了很多重复测试的用例。可以和当前使用的用例套餐结合。
3.1.4  聚类用例集
聚类算法是通过测试用例关联的代码相似程度得出结果的，可以划分出来有哪些测试用例的代码相似程度比较高，这些用例就分为一组。测试的时候可以选取每组各一条用例优先测试。
3.2  精准测试执行
3.2.1  用例智能推荐
根据版本之间代码的变化的来分析出与该函数相关的测试用例，智能的推荐出需要测试的测试用例。输入变更的代码方法名在库里找到代码对应的测试用例。
使用Gerrit REST API获取每个变更的文件然后进行语法分析，找出变更的代码涉及到的函数名和类名。当测试用例关联的函数都没发生改变时再去测试一遍该用例是没有意义的。

假设一个设置锁网的函数如下：
设置锁网参数（）
{
If（需要锁网）
{
代码块1：设置锁网参数=1
}
Else（不需要锁网）
{
代码块2：设置锁网参数=0
}
代码块3: 存储锁网参数
}
在测试设计阶段，精准测试会自动找到未被用例覆盖的代码块，提示补充测试用例。
代码	测试用例
代码块1 ,3	Case1 设置锁网参数为1
代码块2	Case2 设置锁网参数为0
在测试执行阶段，精准测试会自动检查变更所属的代码块，推荐对应的用例
代码变更	推荐用例
代码块1修改	case1
代码块2修改	case2
代码块3修改	case1 case2

3.2.2  接口测试
如果某个函数是接口，那么该函数发生变更时会推荐大量的测试用例，系统检测如果产生了大量的推荐用例就说明该函数是接口函数，就需要提示测试人员进行接口测试。
3.2.3  故障聚类分析
通过聚类分析把用例分为若干个不同的类别，故障分布一般遵循二八定律，功能相近的用例如果有出现错误，那么同类型用例出错的概率也更大。所以当时间不充足的情况下，可以依据聚类结果，每个用例聚类簇随机选几个。如果没有问题，就可以转而去执行下一个聚类中心点。从而减少用例规模。


3.2.4  故障智能定位
传统的测试用例是文字表示的，测试人员提交的故障是比较模糊的自然语言表示，导致开发人员定位故障需要花费很多时间去重现和定位，遗漏掉关联问题的解决。
后续通过代码来表示用例，用例可以直接对应到代码块，通过同类用例中正确执行的用例和错误执行的用例的差异，得到导致失败的代码的可疑位置和准确位置。
3.3  测试管理
3.3.1  版本进度监控
精准测试大规模应用以后
根据代码覆盖率增长曲线生成测试进展，识别系统测试所处阶段和团队工作效率，精准展现项目进度情况。覆盖率的计算精确到每条测试用例覆盖的函数数量。
通过代码覆盖率版本增长图可以看到整个团队的工作效率。一般刚开始测试的时候覆盖率增长快，后期上升很慢了。清晰看到团队的效率趋势并采取相关策略。
需求覆盖率，用例覆盖率和代码覆盖率三个覆盖率显示测试进度。据此可制定新的测试通过标准，例如增量代码覆盖率需要达到90%以上。

3.3.2  版本质量监控
函数的被执行次数和函数的复杂度（行数）的关系图可以直观的看到测试的质量。刚开始测试的时候，测试不充分，复杂度高的函数通常被执行的次数都比较低，代表函数的散点都集中在下图的左上方，随着测试深入，散点将向右侧移动，代表测试越来越充分。


3.3.3  工作量度量
以代码覆盖为基准而不是用例数量为基准进行测试人员工作量计算会更加科学，这样可以避免有些用例步骤过长和过短导致工作量统计不准确的问题。
3.3.4  用例质量评估
每条测试用例对应的代码都可以进行量化分析和统计。传统的测试用例是文字表示的，后续通过代码来表示，赋予测试用例更多的生命力，可以有更多的评价维度。
下图所示的函数覆盖率，分支覆盖率，用例冗余度都是评价指标。


四、效果评价
传统条件下研发关注代码，测试关注需求，之间传递的只是自然语言并没有直接关联。精准测试对于测试来说是一项重大的突破，引领测试走出打开新的局面。通过精准测试，我们可以实现12个应用。精准测试更加智能化可以使用很多AI技术。
后续改进点：
1.一个函数变更推荐的用例有时候很多，有时候又不够，冗余用例如何去除，函数耦合关系如何正确识别出来避免漏测。
2. 随着代码变更增多如何更新对应关系？静态的函数调用关系作为一个基础库，每次动态补充一点，通过多次补齐，建立完整的函数调用关系库。
3. 将记录器集成到TE工具里，实现用户无感操作。
   
五、推广建议
精准测试的大部分功能已经开发完成并上线运行。
http://10.92.16.29:8080/testtools

